# YW Nova Media SDK - 内部架构设计文档

## 1. 系统架构概览

### 1.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        应用层 (Application)                      │
│                      async_api_demo / 用户程序                    │
└──────────────────────────────┬──────────────────────────────────┘
                               │
┌──────────────────────────────┴──────────────────────────────────┐
│                       API 层 (yw_media_api.cpp)                  │
│  yma_init/uninit, yma_open/close_channel, yma_start/stop       │
│  yma_spss_setup/update, yma_ctrl_cmd, ...                      │
└──────────────────────────────┬──────────────────────────────────┘
                               │
┌──────────────────────────────┴──────────────────────────────────┐
│              核心管理层 (yw_media_nova_api)                       │
│  - 线程管理：创建和管理各个 Service 线程                          │
│  - 同步/异步模式切换                                             │
│  - 通道 ID 映射与管理                                            │
│  - 线程间任务调度 (post/信号量)                                   │
└──────────────────────────────┬──────────────────────────────────┘
                               │
          ┌────────────────────┴─────────────────┬─────────────┐
          │                    │                  │             │
┌─────────┴─────────┐ ┌────────┴────────┐ ┌──────┴──────┐ ┌──┴───┐
│  th_venc_svc      │ │  th_jpeg_svc    │ │ th_ain_svc  │ │ ...  │
│  (视频编码服务)    │ │  (JPEG/子码流)   │ │ (音频输入)   │ │      │
│  - 主码流 H264/265│ │  - JPEG抓拍     │ │ - AI采集    │ │      │
│  - 水印叠加       │ │  - 子码流H264/265│ │ - 音频编码  │ │      │
│  - 编码管理       │ │  - 水印叠加      │ │ - NS/AGC    │ │      │
└─────────┬─────────┘ └────────┬────────┘ └──────┬──────┘ └──────┘
          │                    │                  │
┌─────────┴─────────┐ ┌────────┴────────┐ ┌──────┴──────────────┐
│  th_vo_svc        │ │ th_yuv_svc[N]   │ │  th_adec/ao_svc     │
│  (视频输出服务)    │ │ (YUV数据服务)    │ │  (音频解码/输出)     │
│  - VO显示输出     │ │ - 算法喂帧       │ │  - 对讲            │
│  - 显示水印       │ │ - YUV回调        │ │  - 回声消除        │
└─────────┬─────────┘ └────────┬────────┘ └──────┬──────────────┘
          │                    │                  │
┌─────────┴────────────────────┴──────────────────┴─────────────┐
│              硬件抽象层 (Hardware Abstraction Layer)            │
│  - yw_nova_vin_hw/cap: 视频输入硬件封装                         │
│  - yw_nova_venc_hw: 视频编码硬件封装                            │
│  - yw_nova_vo_hw: 视频输出硬件封装                              │
│  - yw_nova_ain_hw: 音频输入硬件封装                             │
│  - yw_nova_ao_hw: 音频输出硬件封装                              │
└────────────────────────────────┬────────────────────────────────┘
                                 │
┌────────────────────────────────┴────────────────────────────────┐
│                   厂商 SDK (Vendor SDK)                          │
│  - libhdal.so: 视频采集、编码、处理                              │
│  - vendor_media.so: 媒体相关                                     │
│  - vendor_isp.so: ISP 处理                                       │
└──────────────────────────────────────────────────────────────────┘
```

### 1.2 模块职责

| 层次 | 模块 | 职责 |
|------|------|------|
| **API层** | yw_media_api.cpp | 对外接口封装，参数校验，错误处理 |
| **核心层** | yw_media_nova_api | 线程创建与管理，任务调度，同步异步切换 |
| **服务层** | yw_nova_*_svc | 独立线程服务，业务逻辑处理，硬件资源管理 |
| **硬件层** | yw_nova_*_hw | 硬件接口封装，参数转换，状态管理 |
| **底层** | libhdal | 硬件驱动，内核交互 |

---

## 2. 线程模型

### 2.1 线程架构

SDK 采用 **多线程服务模型**，每个功能模块运行在独立的线程中：

```
主线程 (VA Thread)
  └─ yw_media_nova_api 实例
      ├─ m_thnovaId (记录主线程ID)
      └─ 管理所有 Service 线程

服务线程：
  ├─ th_venc_svc      [视频编码线程] - 主码流 H264/H265
  ├─ th_jpeg_svc      [JPEG/子码流线程] - JPEG 抓拍 + 子码流
  ├─ th_ain_svc       [音频输入线程] - 音频采集和编码
  ├─ th_vo_svc        [视频输出线程] - VO 显示
  ├─ th_yuv_svc[0..N] [YUV数据线程] - 算法喂帧(每通道独立)
  ├─ th_adec_svc      [音频解码线程] - 音频解码
  ├─ th_ao_svc        [音频输出线程] - 音频播放
  ├─ th_convert_jpg   [截帧线程] - 动态截帧转JPEG
  ├─ th_raw_pull      [RAW拉流线程] - RAW数据拉取
  └─ th_history_play  [历史回放线程] - 录像回放
```

### 2.2 线程基类设计

所有服务线程继承自 `yw_nova_svc_base`：

```cpp
class yw_nova_svc_base {
protected:
    std::thread m_thread;                   // 线程对象
    std::thread::id m_thread_id;            // 线程ID
    ::yw::osal::yw_executor m_executor;     // 任务执行器(基于boost::asio)
    yw_semaphore m_Semaphore;               // 信号量(用于同步)
    
public:
    void Run() {
        m_thread = std::thread([this]() {
            m_thread_id = std::this_thread::get_id();
            m_executor.Run();  // 进入事件循环
        });
    }
    
    void Quit() {
        m_executor.Quit();  // 停止事件循环
    }
    
    void Join() {
        if (m_thread.joinable()) {
            m_thread.join();
        }
    }
    
    bool IsThisThread() const {
        return std::this_thread::get_id() == m_thread_id;
    }
    
    ::yw::osal::yw_executor& GetIoContext() {
        return m_executor;
    }
};
```

**关键设计点：**
1. **Reactor模式**：每个线程内部是一个事件循环 (yw_executor)
2. **任务投递**：通过 `GetIoContext().post(lambda)` 向线程投递任务
3. **线程识别**：`IsThisThread()` 用于判断当前执行是否在本线程
4. **同步机制**：`m_Semaphore` 用于跨线程同步等待

### 2.3 线程创建与销毁

#### 2.3.1 创建流程

```cpp
// 在 yw_media_nova_api 构造函数中
yw_media_nova_api::yw_media_nova_api(...) {
    MediaInit();  // 初始化硬件
    
    // 创建视频编码服务线程
    m_thVencSvc = std::make_shared<yw_nova_venc_svc>(
        m_chSpList, vp_callback, vp_ctx, "th_venc_svc", true);
    m_thVencSvc->Run();  // 启动线程
    
    // 创建 JPEG/子码流服务线程
    m_thJpegSvc = std::make_shared<yw_nova_venc_svc>(
        m_chSpList, vp_callback, vp_ctx, "th_jpeg_svc", false);
    m_thJpegSvc->Run();
    
    // ... 其他线程类似
    
    m_thnovaId = std::this_thread::get_id();  // 记录主线程ID
}
```

#### 2.3.2 销毁流程

```cpp
yw_media_nova_api::~yw_media_nova_api() {
    if (m_thVencSvc) {
        m_thVencSvc->Quit();    // 1. 停止事件循环
        m_thVencSvc->Join();    // 2. 等待线程退出
        m_thVencSvc.reset();    // 3. 释放资源
    }
    // ... 其他线程类似
}
```

**销毁顺序：**
1. 音视频服务线程 (venc/ain)
2. 输出线程 (vo/ao)
3. 辅助线程 (yuv/convert_jpg/history_play)

### 2.4 线程间通信

#### 2.4.1 任务投递 (post)

```cpp
// 从主线程向服务线程投递任务
auto that = std::dynamic_pointer_cast<yw_nova_venc_svc>(m_thVencSvc);
m_thVencSvc->GetIoContext().post([that, vp_ch_id] {
    // 这段代码在 th_venc_svc 线程中执行
    that->ymi_start(vp_ch_id);
});
```

**特点：**
- 非阻塞，立即返回
- 任务在目标线程的事件循环中串行执行
- 适合异步模式

#### 2.4.2 同步调用 (post + wait)

```cpp
// 同步模式：投递任务并等待完成
m_thVencSvc->GetIoContext().post([that, vp_ch_id, &vl_rc] {
    vl_rc = that->ymi_start(vp_ch_id);
    that->m_Semaphore.Post();  // 释放信号量
});
m_thVencSvc->m_Semaphore.Wait();  // 主线程阻塞等待
```

**适用场景：**
- 需要返回值的操作
- 同步模式 API 调用

#### 2.4.3 回调机制

```cpp
// 服务线程通过回调向应用层传递数据
void yw_nova_venc_svc::OnEncData(...) {
    if (m_bSyncFlag) {
        // 同步模式：直接调用回调
        m_ApiCallback(vp_id, sp_frame, m_ApiCtx, vp_ChannelContext);
    } else {
        // 异步模式：封装ACK回调
        auto cb = std::make_shared<t_yma_api_cb_frame>();
        cb->m_cbType = CBT_FRAME;
        cb->vp_id = vp_id;
        cb->sp_media_frame = sp_frame;
        m_AsyncApiCB(cb.get());
    }
}
```

---

## 3. 数据流分析

### 3.1 视频编码数据流

```
┌──────────┐
│ Camera   │ 摄像头硬件
└────┬─────┘
     │ (1) 视频数据采集
     ▼
┌──────────────────┐
│ VIDEOCAP (hdal)  │ 视频采集模块
│ - 多路输出:       │
│   OUT1: 主码流    │
│   OUT2: 子码流    │
│   OUT3: YUV/算法  │
└────┬─────────────┘
     │
     ├─────────────────────────────┬──────────────────────┐
     │                             │                      │
     ▼                             ▼                      ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ VIDEOENC_MAIN   │    │ VIDEOENC_SUB    │    │ VIDEOPROC       │
│ (主码流编码器)   │    │ (子码流编码器)   │    │ (视频处理)       │
│ H264/H265       │    │ H264/H265       │    │ - 缩放/裁剪      │
└────┬────────────┘    └────┬────────────┘    └────┬────────────┘
     │                      │                      │
     │ (2) 硬件编码         │                      ├──────┬────────┐
     ▼                      ▼                      │      │        │
┌─────────────────┐    ┌─────────────────┐       │      ▼        ▼
│ th_venc_svc     │    │ th_jpeg_svc     │       │  算法YUV   JPEG编码
│ ymi_pull_data() │    │ ymi_pull_data() │       │
│ - 拉取数据       │    │ - 拉取数据       │       │
│ - 水印叠加       │    │ - 水印叠加       │       │
│ - 封装Frame      │    │ - 封装Frame      │       │
└────┬────────────┘    └────┬────────────┘       │
     │                      │                      │
     │ (3) 回调通知         │                      │
     ▼                      ▼                      ▼
┌────────────────────────────────────────────────────┐
│              frame_callback (应用层)                │
│  - 保存文件                                        │
│  - 网络传输                                        │
│  - ...                                            │
└────────────────────────────────────────────────────┘
```

**关键步骤说明：**

1. **采集绑定**：
```cpp
// 摄像头 OUT1 绑定到主码流编码器
hd_videocap_bind(
    HD_VIDEOCAP_OUT(ch, 1),  // 采集输出1
    HD_VIDEOENC_IN(0, ch)    // 编码器输入
);
```

2. **数据拉取**：
```cpp
// 在 th_venc_svc 线程中
void yw_nova_venc_svc::ymi_pull_data() {
    while (running) {
        // 等待编码器数据就绪
        hd_videoenc_poll_list(poll_list, ...);
        
        // 拉取编码后的数据
        HD_VIDEOENC_BS bs;
        hd_videoenc_pull_out_buf(enc_path, &bs, ...);
        
        // 封装成 Frame
        auto frame = MakeFrame(&bs);
        
        // 添加水印（软件叠加）
        AddStampToFrame(frame);
        
        // 回调应用层
        OnFrameCallback(frame);
        
        // 释放 buffer
        hd_videoenc_release_out_buf(enc_path, &bs);
    }
}
```

3. **水印叠加**：
   - **硬件叠加**：通过 VIDEOENC 的 SPSS 功能实现，性能高
   - **软件叠加**：在编码后的数据上叠加，灵活但性能略低

### 3.2 JPEG 抓拍数据流

```
┌─────────────┐
│ VIDEOPROC   │ 从 CAP OUT3 输入
│ - 缩放/裁剪  │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│ VIDEOENC_JPEG   │ JPEG 编码器
│ - 动态参数       │
└──────┬──────────┘
       │
       │ (start/stop 控制)
       ▼
┌─────────────────┐
│ th_jpeg_svc     │
│ - 抽帧编码       │
│ - 一次性抓拍     │
└──────┬──────────┘
       │
       ▼
  应用层回调
```

**JPEG 工作流程：**
1. **Open**：创建 JPEG 编码通道，但不启动
2. **Start**：开始抽帧编码（根据 FPS 参数）
3. **Callback**：收到 JPEG 数据
4. **Stop**：停止编码，通道保持打开

### 3.3 音频数据流

```
┌──────────┐
│ Mic 硬件 │
└────┬─────┘
     │
     ▼
┌─────────────────┐
│ AUDIOCAP (hdal) │ 音频采集
│ - PCM 原始数据   │
└────┬────────────┘
     │
     ▼
┌─────────────────┐
│ th_ain_svc      │
│ - 采集线程       │
│ - 帧拆分         │
│ - NS/AGC 处理    │
│ - 音频编码       │
│  (G711/AAC)     │
└────┬────────────┘
     │
     ▼
  应用层回调
  (保存/传输)

对讲音频流：
  应用层
     │
     ▼
┌─────────────────┐
│ th_adec_svc     │ 音频解码
│ (G711/AAC->PCM) │
└────┬────────────┘
     │
     ▼
┌─────────────────┐
│ th_ao_svc       │ 音频输出
│ - 回声消除 (AEC) │
│ - 音量控制       │
└────┬────────────┘
     │
     ▼
┌──────────┐
│ Speaker  │ 扬声器
└──────────┘
```

**关键点：**
- **采集**：PCM 数据 → 拆分成固定帧长 → NS/AGC → 编码
- **播放**：编码数据 → 解码 → 回声消除 → 音量调整 → 输出
- **AEC**：同时采集和播放时，消除扬声器对麦克风的干扰

---

## 4. 代码分层

### 4.1 分层结构

```
┌─────────────────────────────────────────────┐
│          应用层 (Application Layer)          │ async_api_demo
├─────────────────────────────────────────────┤
│           API 层 (API Layer)                │ yw_media_api.cpp
│  - 接口封装                                  │ yma_init, yma_open_channel
│  - 参数校验                                  │
│  - 错误处理                                  │
├─────────────────────────────────────────────┤
│        核心管理层 (Core Layer)               │ _yw_nova_api.hpp
│  - 线程创建与管理                            │ yw_media_nova_api
│  - 同步/异步模式                             │
│  - 通道ID映射                                │
│  - 任务调度                                  │
├─────────────────────────────────────────────┤
│         服务层 (Service Layer)              │ test_svc/*_svc.hpp
│  ┌─────────────────────────────────────┐   │
│  │ yw_nova_venc_svc  (视频编码服务)    │   │
│  │ yw_nova_ain_svc   (音频输入服务)    │   │
│  │ yw_nova_vo_svc    (视频输出服务)    │   │
│  │ yw_nova_ao_svc    (音频输出服务)    │   │
│  │ yw_nova_yuv_svc   (YUV数据服务)     │   │
│  │ ...                                 │   │
│  └─────────────────────────────────────┘   │
│  - 业务逻辑处理                              │
│  - 线程事件循环                              │
│  - 通道状态管理                              │
├─────────────────────────────────────────────┤
│      硬件抽象层 (HAL Layer)                  │ test_svc/*_hw.hpp
│  ┌─────────────────────────────────────┐   │
│  │ yw_nova_vin_hw   (视频输入硬件)     │   │
│  │ yw_nova_venc_hw  (视频编码硬件)     │   │
│  │ yw_nova_vo_hw    (视频输出硬件)     │   │
│  │ yw_nova_ain_hw   (音频输入硬件)     │   │
│  │ yw_nova_ao_hw    (音频输出硬件)     │   │
│  └─────────────────────────────────────┘   │
│  - 硬件接口封装                              │
│  - 参数转换                                  │
│  - 资源管理                                  │
├─────────────────────────────────────────────┤
│        媒体层 (Media Layer)                  │ _yw_media_hd.cpp
│  - 硬件初始化                                │
│  - 通道配置                                  │
│  - 公共参数                                  │
├─────────────────────────────────────────────┤
│       厂商 SDK (Vendor SDK)                  │ libhdal.so
│  - hd_videocap_*    (视频采集)               │ vendor_media.so
│  - hd_videoenc_*    (视频编码)               │
│  - hd_videoproc_*   (视频处理)               │
│  - hd_audiocap_*    (音频采集)               │
│  - hd_audioenc_*    (音频编码)               │
└─────────────────────────────────────────────┘
```

### 4.2 各层详细说明

#### 4.2.1 API 层

**文件：** `sdk/yw_media_api.cpp`

**职责：**
- 对外接口定义
- 参数校验与转换
- 错误码映射
- 句柄管理

**设计模式：** Facade 模式

**关键函数：**
```cpp
E_YMA_ERROR_CODE yma_init(...);
t_yma_channel_id yma_open_channel(...);
E_YMA_ERROR_CODE yma_close_channel(...);
```

**特点：**
- 纯 C++ 接口，使用智能指针
- 全局句柄映射表 `s_th_map`
- 线程安全（互斥锁保护）

#### 4.2.2 核心管理层

**文件：** `sdk/_yw_nova_api.hpp`

**类：** `yw_media_nova_api`

**职责：**
- 创建和管理所有服务线程
- 实现同步/异步模式切换
- 通道 ID 到服务线程的映射
- 跨线程任务调度

**关键成员：**
```cpp
class yw_media_nova_api {
    // 服务线程实例
    std::shared_ptr<yw_nova_venc_svc> m_thVencSvc;
    std::shared_ptr<yw_nova_venc_svc> m_thJpegSvc;
    std::shared_ptr<yw_nova_ain_svc> m_thAinSvc;
    std::shared_ptr<yw_nova_vo_svc> m_thVoSvc;
    std::shared_ptr<yw_nova_yuv_svc> m_thYuvSvc[HD_MAX_VCAP_DEVID];
    // ...
    
    // 通道映射
    std::map<t_yma_channel_id, e_VAType> m_VAID2Type;
    
    // 回调函数
    t_ywa_on_frame_callback m_ApiCallback;        // 同步回调
    t_ywa_async_frame_callback m_AsyncApiCB;      // 异步回调
    
    // 模式标志
    bool m_bSyncFlag;  // true=同步, false=异步
};
```

**线程调度示例：**
```cpp
E_YMA_ERROR_CODE ymi_open_channel(...) {
    // 判断目标线程
    if (vl_FuncType == FUNC_TYPE_MIAN_H264) {
        auto that = m_thVencSvc;
        
        if (m_bSyncFlag) {
            // 同步：投递 + 等待
            m_thVencSvc->GetIoContext().post([that, ...] {
                c_id = that->ymi_open_channel(...);
                that->m_Semaphore.Post();
            });
            m_thVencSvc->m_Semaphore.Wait();
        } else {
            // 异步：仅投递
            m_thVencSvc->GetIoContext().post([that, ...] {
                auto vl_id = that->ymi_open_channel(...);
                that->MediaOpenAck(vl_id, ...);  // 回调通知
            });
        }
    }
}
```

#### 4.2.3 服务层

**文件：** `test_svc/*_svc.hpp`

**基类：** `yw_nova_svc_base`

**派生类：**
- `yw_nova_venc_svc` - 视频编码服务
- `yw_nova_ain_svc` - 音频输入服务
- `yw_nova_vo_svc` - 视频输出服务
- `yw_nova_ao_svc` - 音频输出服务
- `yw_nova_yuv_svc` - YUV 数据服务
- `yw_nova_adec_svc` - 音频解码服务

**职责：**
- 独立线程执行
- 业务逻辑处理
- 硬件资源管理
- 通道生命周期管理

**以 `yw_nova_venc_svc` 为例：**

```cpp
class yw_nova_venc_svc : public yw_nova_vsvc_base {
public:
    // 通道管理
    t_yma_channel_id ymi_open_channel(...);
    E_YMA_ERROR_CODE ymi_close_channel(...);
    E_YMA_ERROR_CODE ymi_start(...);
    E_YMA_ERROR_CODE ymi_stop(...);
    
    // 水印管理
    E_YMA_ERROR_CODE ymi_spss_setup(...);
    E_YMA_ERROR_CODE ymi_spss_update(...);
    
protected:
    // 数据拉取线程
    void ymi_pull_data();
    
    // 编码数据回调
    void OnEncData(...);
    
private:
    // 通道信息列表
    std::vector<std::shared_ptr<yw_channel_info>> m_chInfoList;
    
    // 硬件管理器
    std::shared_ptr<yw_nova_vin_mgr> m_spVinMgr;
};
```

**工作流程：**
1. **初始化**：创建线程，进入事件循环
2. **Open**：创建通道，配置硬件，启动数据拉取
3. **Pull**：循环拉取编码数据
4. **Callback**：数据回调给应用层
5. **Close**：停止拉取，释放硬件资源

#### 4.2.4 硬件抽象层

**文件：** `test_svc/*_hw.hpp`

**职责：**
- 封装厂商 SDK 接口
- 参数格式转换
- 硬件资源生命周期管理

**以视频输入硬件为例：**

```cpp
// yw_nova_vin_cap.hpp - 单个摄像头封装
class yw_nova_vin_cap {
public:
    // 打开采集通道
    HD_RESULT OpenVCap(int dev_id, HD_DIM& dim);
    
    // 启动采集
    HD_RESULT StartVCap();
    
    // 停止采集
    HD_RESULT StopVCap();
    
    // 绑定到编码器
    HD_RESULT BindToEnc(HD_PATH_ID enc_path);
    
private:
    HD_PATH_ID m_cap_path;  // 采集路径
    HD_PATH_ID m_ctrl_path; // 控制路径
};

// yw_nova_vin_mgr.h - 多路摄像头管理
class yw_nova_vin_mgr {
public:
    static std::shared_ptr<yw_nova_vin_cap> GetVDevCap(uint8_t dev_id);
    
    // 硬件初始化
    static HD_RESULT MediaHdInit();
    
private:
    static std::vector<std::shared_ptr<yw_nova_vin_cap>> s_VDevCapList;
};
```

**设计模式：**
- **Singleton**：全局管理器（vin_mgr）
- **Factory**：创建硬件实例
- **RAII**：资源自动管理

#### 4.2.5 媒体层

**文件：** `test_svc/_yw_media_hd.cpp`

**类：** `yw_media_hd`

**职责：**
- 全局硬件初始化
- 公共参数配置
- 设备信息管理

**关键函数：**
```cpp
class yw_media_hd {
public:
    // 硬件初始化
    static E_YMA_ERROR_CODE MediaHdInit();
    
    // 硬件反初始化
    static void MediaHdExit();
    
    // 释放未释放的内存
    static void free_mem();
    
    // 全局配置
    static std::atomic<E_DEVICE_TYPE> m_device_type;
    static std::atomic<VIDEO_OUT_CHN> m_EnableVgaOut;
    static std::map<int, int> m_videoHWChnMap;  // 通道映射
};
```

### 4.3 模块依赖关系

```
┌──────────────┐
│ Application  │
└──────┬───────┘
       │ depends on
       ▼
┌──────────────┐
│  API Layer   │
└──────┬───────┘
       │ creates
       ▼
┌──────────────┐
│  Core Layer  │
└──────┬───────┘
       │ creates
       ▼
┌──────────────┐
│ Service Layer│ ◄──── 使用 ───── ┌──────────────┐
└──────┬───────┘                  │   HAL Layer  │
       │ uses                     └──────┬───────┘
       │                                 │ wraps
       ▼                                 ▼
┌─────────────────────────────────────────┐
│          Vendor SDK (libhdal)           │
└─────────────────────────────────────────┘
```

---

## 5. 同步与异步模式

### 5.1 同步模式

**特点：**
- API 调用阻塞，等待操作完成
- 适合单线程应用
- 实现简单，易于调试

**工作流程：**
```
应用线程 (VA Thread)
    │
    ├─ yma_open_channel()
    │   │
    │   ├─ post task to th_venc_svc
    │   │   ▼
    │   │  [th_venc_svc 执行 open]
    │   │   │
    │   │   └─ Semaphore.Post()
    │   │
    │   └─ Semaphore.Wait()  ◄───── 阻塞等待
    │
    └─ 返回 channel_id
```

**实现机制：**
```cpp
// 1. 投递任务到服务线程
m_thVencSvc->GetIoContext().post([that, &result] {
    result = that->ymi_open_channel(...);
    that->m_Semaphore.Post();  // 释放信号量
});

// 2. 主线程等待
m_thVencSvc->m_Semaphore.Wait();  // 阻塞

// 3. 返回结果
return result;
```

### 5.2 异步模式

**特点：**
- API 立即返回，操作在后台执行
- 通过回调通知结果
- 适合多通道高并发场景
- 性能更高，但编程复杂度增加

**工作流程：**
```
应用线程
    │
    ├─ yma_open_channel()  ◄───── 立即返回
    │   │
    │   └─ post task to th_venc_svc
    │       ▼
    │      [th_venc_svc 执行 open]
    │       │
    │       └─ MediaOpenAck()
    │           │
    │           └─ async_callback(CBT_OPEN)
    │               │
    │               ▼
    │           应用层回调
```

**回调事件类型：**
```cpp
enum class e_yma_cb_type {
    CBT_OPEN,   // 通道打开完成
    CBT_CLOSE,  // 通道关闭完成
    CBT_FRAME   // 帧数据到达
};

struct t_yma_api_cb_open {
    e_yma_cb_type m_cbType = CBT_OPEN;
    E_YMA_ERROR_CODE m_result;
    t_yma_channel_id vp_id;
    e_media_ch_type m_chType;
    int m_chNo;
};
```

**实现示例：**
```cpp
// 服务线程中
void yw_nova_venc_svc::MediaOpenAck(...) {
    if (m_AsyncApiCB) {
        auto cb = std::make_shared<t_yma_api_cb_open>();
        cb->m_cbType = CBT_OPEN;
        cb->m_result = YMAEC_OK;
        cb->vp_id = vl_id;
        cb->m_chType = vp_chType;
        cb->m_chNo = vp_chNo;
        
        // 调用应用层异步回调
        m_AsyncApiCB(cb.get());
    }
}
```

### 5.3 模式对比

| 特性 | 同步模式 | 异步模式 |
|------|----------|----------|
| **API 行为** | 阻塞 | 立即返回 |
| **结果获取** | 返回值 | 回调通知 |
| **编程复杂度** | 低 | 高 |
| **性能** | 较低（阻塞等待） | 高（无阻塞） |
| **适用场景** | 单线程，简单应用 | 多通道，高性能需求 |
| **状态管理** | API 内部管理 | 应用层管理 |
| **错误处理** | 直接返回错误码 | 回调中返回 |

---

## 6. 关键设计模式

### 6.1 线程池模式 (Thread Pool)

虽然不是传统的线程池，但采用了固定数量的工作线程：
- 每个功能模块一个专用线程
- 任务通过事件循环分发
- 避免频繁创建/销毁线程的开销

### 6.2 生产者-消费者模式

**生产者：** 硬件（摄像头、麦克风）  
**消费者：** 服务线程  
**队列：** 硬件 buffer 队列

```cpp
// 生产者：硬件采集
while (capturing) {
    hd_videocap_pull_out_buf(...);  // 从硬件拉取
    // ... 处理数据
    hd_videocap_release_out_buf(...);  // 归还 buffer
}
```

### 6.3 观察者模式 (Observer)

**主题：** 服务线程  
**观察者：** 应用层回调

```cpp
// 服务线程通知观察者
void OnEncData(...) {
    if (m_ApiCallback) {
        m_ApiCallback(id, frame, ctx, ch_ctx);  // 通知应用层
    }
}
```

### 6.4 策略模式 (Strategy)

**策略：** 同步 vs 异步

```cpp
if (m_bSyncFlag) {
    // 同步策略：阻塞等待
    post_and_wait(...);
} else {
    // 异步策略：投递即返回
    post_only(...);
}
```

### 6.5 单例模式 (Singleton)

**全局管理器：**
- `yw_nova_vin_mgr` - 视频输入管理器
- `yw_media_hd` - 硬件全局配置

```cpp
class yw_nova_vin_mgr {
private:
    static std::vector<std::shared_ptr<yw_nova_vin_cap>> s_VDevCapList;
    
public:
    static std::shared_ptr<yw_nova_vin_cap> GetVDevCap(uint8_t dev_id) {
        if (dev_id < s_VDevCapList.size()) {
            return s_VDevCapList[dev_id];
        }
        return nullptr;
    }
};
```

### 6.6 外观模式 (Facade)

**Facade：** `yw_media_api.cpp`

```cpp
E_YMA_ERROR_CODE yma_init(...) {
    // 简化的外部接口
    auto ptr = std::make_shared<yw_media_nova_api>(...);
    // 隐藏内部复杂性
    return YMAEC_OK;
}
```

---

## 7. 性能优化

### 7.1 零拷贝 (Zero-Copy)

**原理：** 直接使用硬件 buffer，避免内存拷贝

```cpp
// 拉取硬件 buffer
HD_VIDEOENC_BS bs;
hd_videoenc_pull_out_buf(enc_path, &bs, ...);

// 封装成 Frame（共享buffer，不拷贝）
auto frame = std::make_shared<yw_media_frame>();
frame->m_spFrameData = std::make_shared<yw_frame>(
    bs.p_stream_buf,  // 直接使用硬件内存
    bs.data_size
);

// 回调应用层
callback(frame);

// 应用层处理完毕后自动释放
// Frame 析构时调用 hd_videoenc_release_out_buf
```

### 7.2 硬件水印 (Hardware OSD)

利用编码器的 SPSS 功能实现硬件水印叠加：
- 无 CPU 开销
- 无内存拷贝
- 实时更新

```cpp
// 配置硬件水印
HD_VIDEOENC_SPSS_CFG spss_cfg;
spss_cfg.enable = TRUE;
spss_cfg.str = "Camera 01";
spss_cfg.pos_x = 10;
spss_cfg.pos_y = 10;

hd_videoenc_set(enc_path, HD_VIDEOENC_PARAM_SPSS, &spss_cfg);
```

### 7.3 异步非阻塞

- 所有硬件操作使用 poll 模式
- 服务线程采用事件驱动
- 避免无谓的 CPU 占用

```cpp
// poll 等待数据就绪
if (HD_OK == hd_videoenc_poll_list(poll_list, count, timeout)) {
    // 有数据才拉取
    hd_videoenc_pull_out_buf(...);
}
```

### 7.4 多路并发

- 主码流和子码流独立线程
- 每个摄像头的 YUV 数据独立线程
- 最大化并行度

### 7.5 内存池

使用智能指针和引用计数自动管理内存：
```cpp
std::shared_ptr<yw_media_frame> sp_frame;
// 自动释放，无内存泄漏
```

---

## 8. 关键数据结构

### 8.1 通道信息 (Channel Info)

```cpp
class yw_channel_info {
public:
    int m_chNo;                                     // 通道号
    e_media_ch_type m_chType;                       // 通道类型
    t_yma_channel_id m_ch_id;                       // 通道ID
    
    std::shared_ptr<t_media_encode_param> m_enc_param;  // 编码参数
    
    // 硬件路径
    HD_PATH_ID m_cap_path;
    HD_PATH_ID m_enc_path;
    HD_PATH_ID m_proc_path;
    
    // 状态
    e_channel_state m_state;  // IDLE/OPENED/RUNNING/CLOSED
    
    // 水印管理
    std::shared_ptr<yw_nova_vin_stamp_mgr> m_spStampMgr;
};
```

### 8.2 帧数据 (Media Frame)

```cpp
class yw_media_frame {
public:
    std::shared_ptr<yw_frame> m_spFrameData;        // 帧数据
    std::shared_ptr<t_media_frame_info> m_spFrameInfo;  // 帧信息
    
    uint32_t GetLen() const;
    int GetChNo() const;
    uint64_t GetPTS() const;
    e_media_frame_type GetFrameType() const;
};

struct t_media_frame_info {
    uint32_t v_Length;                  // 结构体长度
    uint32_t v_channel;                 // 通道号
    uint64_t v_PTS;                     // 时间戳
    e_media_frame_type v_FrameType;     // 帧类型
    e_media_frame_format v_FrameFormat; // 帧格式
    
    union {
        t_video_frame_info v_VideoInfo;  // 视频信息
        t_audio_frame_info v_AudioInfo;  // 音频信息
    } v_Info;
};
```

### 8.3 水印管理 (Stamp Manager)

```cpp
class yw_nova_vin_stamp_mgr {
public:
    // 设置水印布局
    void SetupStamp(const t_vec_spss_rect& vp_rect);
    
    // 更新水印文本
    void UpdateStamp(const t_media_spss_update& vp_update);
    
    // 应用到硬件
    void ApplyToHardware(HD_PATH_ID enc_path);
    
private:
    std::vector<yw_nova_vin_stamp_ex> m_stamps;  // 水印列表
};
```

---

## 9. 故障处理与容错

### 9.1 摄像头掉线检测

```cpp
int yw_nova_info::CheckCameraStatus(int video_num) {
    int status = 0;
    
    for (int i = 0; i < video_num; i++) {
        auto cap = yw_nova_vin_mgr::GetVDevCap(i);
        if (cap && cap->IsConnected()) {
            status |= (1 << i);  // 位图表示状态
        }
    }
    
    return status;
}
```

### 9.2 视频丢失处理

当检测到摄像头掉线时：
1. 叠加"视频丢失"图片
2. 继续编码（黑屏或默认图片）
3. 定期检测，自动恢复

```cpp
void UpdateVideoLostCameraState(int ch, bool is_lost) {
    if (is_lost) {
        // 显示视频丢失水印
        update.v_Index = VPP_INFO_LostFd;
        update.v_Hide = 0;
        yma_spss_update_text(handle, ch, update, func_type);
    } else {
        // 隐藏视频丢失水印
        update.v_Hide = 1;
        yma_spss_update_text(handle, ch, update, func_type);
    }
}
```

### 9.3 线程异常处理

```cpp
// 线程内部捕获异常
void Run() {
    try {
        m_executor.Run();
    } catch (const std::exception& e) {
        X_ERR("Thread exception: %s", e.what());
        // 记录日志，通知上层
    }
}
```

### 9.4 资源泄漏防护

- **RAII 原则**：所有资源用智能指针管理
- **析构保证**：析构函数确保资源释放
- **定期检查**：可选的资源泄漏检测

```cpp
~yw_channel_info() {
    // 自动释放硬件资源
    if (m_enc_path > 0) {
        hd_videoenc_close(m_enc_path);
        m_enc_path = 0;
    }
}
```

---

## 10. 调试与诊断

### 10.1 日志系统

**日志级别：**
```cpp
enum YW_LOG_LEVEL {
    YLL_DEBUG,   // 调试信息
    YLL_INFO,    // 一般信息
    YLL_WARN,    // 警告
    YLL_ERR      // 错误
};
```

**使用方法：**
```cpp
X_LOG_SET_LEVEL(YLL_INFO);  // 设置级别

X_DEBUG("Debug info: %d", value);
X_INFO("Channel %d opened", ch_no);
X_WARN("Buffer full, dropping frame");
X_ERR("Failed to open device: %d", ret);
```

### 10.2 状态查询

```cpp
// 查询通道状态
auto info = GetChannelInfo(ch_id);
if (info) {
    printf("State: %d\n", info->m_state);
    printf("FPS: %d\n", info->m_enc_param->v_param.v_H264Param.v_FPS);
}

// 检查摄像头状态
int status = yma_check_camera_status(handle, video_num);
for (int i = 0; i < video_num; i++) {
    if (status & (1 << i)) {
        printf("Camera %d: Online\n", i);
    } else {
        printf("Camera %d: Offline\n", i);
    }
}
```

### 10.3 性能监控

```cpp
// 帧率统计
uint64_t frame_count = 0;
uint64_t start_time = get_tickcount64();

// 每秒统计
if ((get_tickcount64() - start_time) >= 1000) {
    X_INFO("FPS: %llu", frame_count);
    frame_count = 0;
    start_time = get_tickcount64();
}
```

### 10.4 Dump 数据

```cpp
// 保存原始数据用于分析
#ifdef DEBUG_DUMP_RAW_DATA
void DumpFrame(const yw_media_frame& frame) {
    char filename[256];
    snprintf(filename, sizeof(filename), 
             "/tmp/dump_ch%d_%llu.h264",
             frame.GetChNo(),
             frame.GetPTS());
    
    FILE* fp = fopen(filename, "wb");
    if (fp) {
        fwrite(frame.GetData(), 1, frame.GetLen(), fp);
        fclose(fp);
    }
}
#endif
```

---

## 11. 扩展性设计

### 11.1 新增服务线程

**步骤：**
1. 继承 `yw_nova_svc_base`
2. 实现业务逻辑
3. 在 `yw_media_nova_api` 中创建和管理

```cpp
class yw_new_svc : public yw_nova_svc_base {
public:
    yw_new_svc(...)
        : yw_nova_svc_base("th_new_svc") {
        // 初始化
    }
    
protected:
    void ProcessData() {
        // 业务逻辑
    }
};

// 在 yw_media_nova_api 中
m_thNewSvc = std::make_shared<yw_new_svc>(...);
m_thNewSvc->Run();
```

### 11.2 支持新的编码格式

**步骤：**
1. 在 `e_media_frame_type` 中添加类型
2. 在编码参数 union 中添加参数结构
3. 在服务线程中添加处理逻辑
4. 在硬件层添加编码器封装

### 11.3 多平台支持

**当前架构支持：**
- 通过 HAL 层隔离平台差异
- 不同平台实现各自的 `*_hw` 模块
- API 层和服务层保持不变

**移植步骤：**
1. 实现新平台的 `yw_media_hd`
2. 实现新平台的 `*_hw` 模块
3. 调整 CMakeLists.txt 平台选择

---

## 12. 总结

### 12.1 架构优势

1. **模块化设计**：清晰的分层，职责明确
2. **线程安全**：独立线程，事件驱动，减少竞态
3. **高性能**：零拷贝，硬件加速，异步非阻塞
4. **易扩展**：基于继承和多态，便于添加新功能
5. **易维护**：统一的接口，良好的封装

### 12.2 改进方向

1. **更细粒度的线程池**：根据负载动态调整线程
2. **更智能的资源管理**：自动回收空闲资源
3. **更完善的错误恢复**：自动重启失败的通道
4. **性能分析工具**：内置性能监控和瓶颈分析
5. **配置化**：更多参数支持运行时配置

### 12.3 注意事项

1. **线程同步**：注意跨线程调用的同步问题
2. **资源限制**：硬件资源有限，注意通道数限制
3. **性能权衡**：水印、缩放等操作会影响性能
4. **内存管理**：虽然使用智能指针，仍需注意循环引用
5. **平台差异**：不同芯片平台的 API 可能有差异

---

**文档版本：** v2.0  
**更新日期：** 2024-01-01  
**维护者：** Media SDK 开发团队

