# 视频服务使用示例

## 1. 基本使用流程

```cpp
#include "MediaManager.h"
#include "CaptureThread.h"
#include <iostream>

int main() {
    // 1. 创建 MediaManager
    MediaManager mediaMgr;
    
    // 2. 初始化（创建所有服务）
    if (!mediaMgr.init()) {
        std::cerr << "Failed to initialize MediaManager" << std::endl;
        return -1;
    }
    
    // 3. 创建采集源
    auto capture = std::make_shared<CaptureThread>(1920, 1080, "/dev/video0");
    mediaMgr.setCaptureSource(capture);
    
    // 4. 配置编码服务
    auto encoderSvc = mediaMgr.getEncoderService();
    EncodeParams encParams;
    encParams.width = 1920;
    encParams.height = 1080;
    encParams.bitrate = 2000000;  // 2Mbps
    encParams.fps = 30;
    encParams.useH265 = false;    // H264
    encoderSvc->setEncodeParams(encParams);
    
    // 设置编码数据回调
    encoderSvc->setEncodeCallback([](const EncodedFrame& frame) {
        std::cout << "Encoded frame: " << frame.size << " bytes, "
                  << "timestamp: " << frame.timestamp << std::endl;
        // 保存文件或网络传输
        // saveToFile(frame.data.get(), frame.size);
    });
    
    // 5. 配置显示服务
    auto outputSvc = mediaMgr.getOutputService();
    DisplayParams dispParams;
    dispParams.displayWidth = 1920;
    dispParams.displayHeight = 1080;
    dispParams.x = 0;
    dispParams.y = 0;
    dispParams.layer = 0;
    outputSvc->setDisplayParams(dispParams);
    
    // 6. 配置 YUV 输出服务（算法喂帧）
    auto yuvSvc = mediaMgr.getYUVService();
    yuvSvc->setYUVCallback([](const VideoFrame& frame) {
        std::cout << "YUV frame: " << frame.width << "x" << frame.height
                  << ", timestamp: " << frame.timestamp << std::endl;
        // 算法处理
        // processAlgorithm(frame.data, frame.width, frame.height);
    });
    
    // 7. 启动所有服务
    mediaMgr.start();
    
    // 8. 运行...
    std::cout << "Press Enter to stop..." << std::endl;
    std::cin.get();
    
    // 9. 停止所有服务
    mediaMgr.stop();
    
    // 10. 清理
    mediaMgr.deinit();
    
    return 0;
}
```

## 2. 数据流说明

```
CaptureThread (采集线程)
    │
    │ 每帧数据通过回调
    ▼
MediaManager::onFrameAvailable()
    │
    ├─→ VideoEncoderSvc::inputFrame()  → 编码 → 回调应用层
    ├─→ VideoOutputSvc::inputFrame()   → 显示 → VO硬件
    └─→ YUVOutputSvc::inputFrame()     → 回调 → 算法处理
```

## 3. 线程模型

```
主线程
  └─ MediaManager
      ├─ CaptureThread (采集线程)
      ├─ VideoEncoderSvc (编码线程)
      ├─ VideoOutputSvc (显示线程)
      └─ YUVOutputSvc (YUV输出线程)
```

每个服务运行在独立线程中，通过队列和回调进行数据传递。

## 4. 注意事项

1. **数据生命周期**：
   - VideoFrame 中的数据指针指向 mmap 映射的内存
   - 在回调中使用数据时，需要确保数据不会被覆盖
   - 如果需要长时间处理，建议拷贝数据

2. **性能优化**：
   - 编码服务：使用硬件编码器（如果可用）
   - 显示服务：使用硬件加速
   - YUV 服务：避免在回调中做耗时操作

3. **错误处理**：
   - 所有服务都有异常处理
   - 回调中的异常不会影响其他服务

4. **资源管理**：
   - 使用智能指针自动管理资源
   - 确保正确调用 stop() 和 deinit()

