# 视频服务架构设计（基于媒体库架构）

## 1. 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    应用层 (Application)                    │
│              main.cpp / 用户程序                          │
└──────────────────────────┬────────────────────────────────┘
                           │
┌──────────────────────────┴────────────────────────────────┐
│              MediaManager (核心管理层)                      │
│  - 管理所有服务线程                                        │
│  - 任务调度                                                │
│  - 生命周期管理                                            │
└──────────────────────────┬────────────────────────────────┘
                           │
          ┌────────────────┴────────────────┬──────────────┐
          │                                  │              │
┌─────────┴─────────┐  ┌─────────┴─────────┐  ┌──────────┴─────────┐
│ VideoEncoderSvc   │  │ VideoOutputSvc    │  │ YUVOutputSvc       │
│ (视频编码服务)     │  │ (视频输出服务)     │  │ (YUV数据输出服务)   │
│ - H264/H265编码   │  │ - VO显示          │  │ - 算法喂帧         │
│ - 编码参数管理     │  │ - 显示管理        │  │ - YUV回调          │
└─────────┬─────────┘  └─────────┬─────────┘  └──────────┬─────────┘
          │                      │                       │
          └──────────────────────┴───────────────────────┘
                           │
┌──────────────────────────┴────────────────────────────────┐
│              CaptureThread (视频采集)                       │
│  - V4L2 采集                                               │
│  - 多缓冲管理                                               │
│  - 数据输出到三个服务                                        │
└────────────────────────────────────────────────────────────┘
```

## 2. 数据流设计

### 2.1 视频编码数据流

```
CaptureThread (生产者)
    │
    │ VideoFrame (YUV数据)
    ▼
VideoEncoderSvc (消费者)
    │
    │ 编码处理 (软件编码或硬件编码)
    ▼
编码后的数据 (H264/H265)
    │
    │ 回调
    ▼
应用层 (保存文件/网络传输)
```

### 2.2 视频输出数据流

```
CaptureThread (生产者)
    │
    │ VideoFrame (YUV数据)
    ▼
VideoOutputSvc (消费者)
    │
    │ 格式转换/缩放
    ▼
VO硬件 (显示输出)
    │
    ▼
屏幕显示
```

### 2.3 YUV数据输出流

```
CaptureThread (生产者)
    │
    │ VideoFrame (YUV数据)
    ▼
YUVOutputSvc (消费者)
    │
    │ 直接传递或格式转换
    ▼
应用层回调 (算法处理)
```

## 3. 服务基类设计

### 3.1 ServiceBase (服务基类)

```cpp
class ServiceBase {
protected:
    std::thread m_thread;
    std::atomic<bool> m_running{false};
    std::mutex m_mutex;
    
public:
    virtual ~ServiceBase() = default;
    
    // 启动服务
    virtual void start();
    
    // 停止服务
    virtual void stop();
    
    // 线程主循环（子类实现）
    virtual void run() = 0;
    
    // 投递任务到服务线程
    template<typename F>
    void post(F&& f);
};
```

## 4. 三个服务设计

### 4.1 VideoEncoderSvc (视频编码服务)

**职责：**
- 接收 YUV 数据
- 编码为 H264/H265
- 回调编码后的数据

**接口：**
```cpp
class VideoEncoderSvc : public ServiceBase {
public:
    // 设置编码参数
    void setEncodeParams(const EncodeParams& params);
    
    // 设置编码数据回调
    void setEncodeCallback(std::function<void(const EncodedFrame&)> callback);
    
    // 输入 YUV 数据
    void inputFrame(const VideoFrame& frame);
    
protected:
    void run() override;
    void encodeFrame(const VideoFrame& frame);
};
```

### 4.2 VideoOutputSvc (视频输出服务)

**职责：**
- 接收 YUV 数据
- 输出到 VO 硬件
- 管理显示窗口

**接口：**
```cpp
class VideoOutputSvc : public ServiceBase {
public:
    // 设置显示参数
    void setDisplayParams(const DisplayParams& params);
    
    // 输入 YUV 数据
    void inputFrame(const VideoFrame& frame);
    
    // 显示控制
    void show();
    void hide();
    
protected:
    void run() override;
    void displayFrame(const VideoFrame& frame);
};
```

### 4.3 YUVOutputSvc (YUV数据输出服务)

**职责：**
- 接收 YUV 数据
- 回调给应用层（算法处理）

**接口：**
```cpp
class YUVOutputSvc : public ServiceBase {
public:
    // 设置 YUV 回调
    void setYUVCallback(std::function<void(const VideoFrame&)> callback);
    
    // 输入 YUV 数据
    void inputFrame(const VideoFrame& frame);
    
protected:
    void run() override;
    void processFrame(const VideoFrame& frame);
};
```

## 5. MediaManager (核心管理器)

**职责：**
- 创建和管理所有服务
- 协调数据流转
- 生命周期管理

**接口：**
```cpp
class MediaManager {
public:
    // 初始化
    bool init();
    
    // 反初始化
    void deinit();
    
    // 启动所有服务
    void start();
    
    // 停止所有服务
    void stop();
    
    // 获取服务实例
    std::shared_ptr<VideoEncoderSvc> getEncoderService();
    std::shared_ptr<VideoOutputSvc> getOutputService();
    std::shared_ptr<YUVOutputSvc> getYUVService();
    
    // 设置采集源
    void setCaptureSource(std::shared_ptr<CaptureThread> capture);
    
private:
    std::shared_ptr<CaptureThread> m_capture;
    std::shared_ptr<VideoEncoderSvc> m_encoderSvc;
    std::shared_ptr<VideoOutputSvc> m_outputSvc;
    std::shared_ptr<YUVOutputSvc> m_yuvSvc;
};
```

## 6. 数据流转机制

### 6.1 生产者-消费者模式

```
CaptureThread (生产者)
    │
    │ 通过回调或队列
    ▼
┌─────────────────────────────────────┐
│  三个服务线程 (消费者)                │
│  - VideoEncoderSvc                  │
│  - VideoOutputSvc                   │
│  - YUVOutputSvc                     │
└─────────────────────────────────────┘
```

### 6.2 数据传递方式

**方案1：回调方式（推荐）**
```cpp
// CaptureThread 提供回调接口
void setFrameCallback(std::function<void(const VideoFrame&)> callback);

// MediaManager 注册回调
m_capture->setFrameCallback([this](const VideoFrame& frame) {
    // 分发到三个服务
    m_encoderSvc->inputFrame(frame);
    m_outputSvc->inputFrame(frame);
    m_yuvSvc->inputFrame(frame);
});
```

**方案2：队列方式**
```cpp
// 每个服务维护一个队列
class VideoEncoderSvc {
    std::queue<VideoFrame> m_frameQueue;
    std::condition_variable m_cv;
    
    void inputFrame(const VideoFrame& frame) {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_frameQueue.push(frame);
        m_cv.notify_one();
    }
};
```

## 7. 实现步骤

1. **第一步：实现服务基类**
   - ServiceBase (线程管理、任务投递)

2. **第二步：实现三个服务**
   - VideoEncoderSvc
   - VideoOutputSvc
   - YUVOutputSvc

3. **第三步：实现 MediaManager**
   - 服务创建和管理
   - 数据流转协调

4. **第四步：集成测试**
   - 完整流程测试
   - 性能测试

## 8. 关键设计点

### 8.1 线程安全
- 每个服务独立线程
- 使用互斥锁保护共享数据
- 使用原子变量管理状态

### 8.2 零拷贝
- VideoFrame 只包含指针，不拷贝数据
- 使用引用计数管理生命周期

### 8.3 异步非阻塞
- 服务线程使用事件循环
- 数据通过队列传递
- 避免阻塞采集线程

### 8.4 资源管理
- RAII 原则
- 智能指针管理资源
- 确保资源正确释放

